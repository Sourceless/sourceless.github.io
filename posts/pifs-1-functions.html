<!DOCTYPE html>

<html>
    <head>
        <title>Sourceless - Programming in Functional Style: Functions</title>
        <meta name="description" content=""/>
        <meta name="keywords" content="["pifs" "functional programming"]"/>
        <meta charset="utf-8"/>
        <meta name="author" content="Laurence Pakenham-Smith"/>
        <meta name="copyright" content="2020-2025 Laurence Pakenham-Smith"/>
        <meta name="robots" content="index"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <link rel="stylesheet" type="text/css" href="https://sourceless.org/assets/css/main.css"/>
    </head>

    <body>
        <code id="content">
            <h1>sourceless</h1>


<a href="https://sourceless.org">index</a>

    <a href="https://sourceless.org/about.html">about</a>

    <a href="https://sourceless.org/contact.html">contact</a>


            <h2>Programming in Functional Style: Functions</h2><p>If you've been programming for more than a couple of years, you've probably heard of functional programming. You might even have picked up a functional language and played around with it.</p><p>Functional programming languages span a range of styles. On the one hand, you have LISP-style languages, the masters of which pull off incredible feats of language reinvention. On the other, you have Haskell wizards, whose carefully structured types give their programs and data structures properties that C programmes can only dream of.</p><p>However, functional programming is not confined to functional languages; the languages merely support the use of functional programs. So what does it mean to be <em>functional</em>?</p><p>Surely every programming language is functional, in the sense that it <em>does</em> something?</p><p>True &ndash; but "functional" in this context means centering your programs around <em>functions</em>.</p><h3>Functions</h3><p>You know what a function is, right? Well, you probably have some conception at least. You migh have heard it in a maths class, or you know it's what you make every time you write <code>def</code> or <code>function&#40;&#41;</code>.</p><p>Here's a very loose definition:<blockquote><p> A function f is a transformation that takes some input X and returns some  output f(X).  </p></blockquote>This limited definition does fall apart somewhat quickly, unfortunately.</p><p>Or does it?</p><h4>Counterexample 1: Multiple inputs</h4><p>Functions in <code>&lt;favourite language&gt;</code> can take multiple arguments, but the definition given only allows a single input!</p><p>I won't go into detail in this post about the various ways we can deal with this, but a simple solution to this is lists.</p><blockquote><p> Something that looks like a function with N arguments can be transformed into  a function with one argument that is a list of length N </p></blockquote><h4>Counterexample 2: The state of the world</h4><p>Functions in <code>&lt;favourite language&gt;</code> might behave differently depending on their context!</p><p>This means that for some input <code>X</code>, there might be a different output for <code>f&#40;X&#41;</code>!</p><p>Unless, that is...</p><blockquote><p> When something looks like a function, but changes depending on its context,  you can turn it into a function by including the context in the input. </p></blockquote><p>An example of this is reading a file. Depending what's on disk, you'll get a different result! But if you consider what's on disk to be part of the input...</p><h3>Purity</h3><p>I lied to you with the earlier definition of a function. What I actually gave was the definition of a <em>pure</em> function.</p><p>Why do we care about a function being pure, though? Isn't it a lot of hassle to rewrite inputs and pass the entire world to the function every time? Well yes, okay, if you insist. I promise that sometimes there's a good reason to want it though.</p><p>The best reason is that **you can always tell what a pure function's output will be just from its outputs**.</p><p>Sound useful yet? No? Uh... well, look, what does that imply? What can you do with a pure function that your everday javascript function doesn't let you do?</p><h4>Referential Integrity</h4><p>Okay, don't let your eyes glaze over. I promise that I'll stop using five-dollar words.</p><p>Consider that in a pure function, you can always tell what the output will bu just by knowing the input.</p><p>So, it's easier to reason about! Especially when you've got a lot of these pure functions glued together. And to wind back to 'referential integrity', all it means is that you can tell what the output will be just by looking at the input. There's no outside context involved.</p><p>Some languages, like Haskell, enforce this. Most others don't care. But you'll find this idea of things being easy to reason about pop up <em>everywhere</em>.</p><p>You just have to look.</p><p>Think about dependency injection. What is it really? It's about making a core program that you can plug the context into, so that you can make it easier to reason about &ndash; usually with the goal of making it easier to test!</p><p>There are other reasons you might have to want a program to be easy to reason aboub, such as wanting to prove it works a certain way, or wanting to match some existing modeling method.</p><p>But the practical upshot for most is that it makes building and testing code WAY easier.</p><h4>Memoization</h4><p>Sorry! I can't help myself! Does it help if I just say 'caching' instead?</p><p>Because that's all memoization really is. Caching at a micro level. And if you think about it, purity is really important to caching. If you want to load an image from a webserver quick, you want to cache it, right? But you can only <em>do</em> that if you're reasonably sure that the image is going to be the same one every time you ask for it.</p><p>So purity really matters when you want to cache something and avoid extra work.</p><h3>Bringing it all together</h3><p>So, what did we learn?</p><blockquote><p> A pure function f tranforms some input X to an output f(X) </p></blockquote><p>Pure functions:</p><ul><li>Are easier to reason about</li><li>Are easier to test</li><li>Have <em>referential integrity</em></li><li>Can be easily <em>memoized</em></li></ul><p>I plan on doing a few more of these, so please reach out if this post helped you!</p>
            <br/>
            Posted 2023-07-17
            <br/>
            <br/>
            
<a href="https://sourceless.org/posts/make-your-own-free-password-manager.html">‚Üê Make your own (free) password manager</a>



        </code>
    </body>
</html>
